# 享学笔记 

## 插件化

类加载流程图：双亲委派机制

DexClassLoader ==PathDexClassLoader

应用							

BootClassLoader

系统

![](C:\Users\Abero\Desktop\classloader.png)

插件化类加载实现流程图

![](C:\Users\Abero\Desktop\plugin_classloader.png)



资源加载

```
AssetManager assetManager = AssetManager.class.newInstance();
Method addAssetPathMethod = assetManager.getClass().getMethod("addAssetPath", String.class);
addAssetPathMethod.setAccessible(true);
addAssetPathMethod.invoke(assetManager, apkPath);
Resources hostResource = context.getResources();
resources = new Resources(assetManager, context.getResources().getDisplayMetrics(),
        context.getResources().getConfiguration());
```

方式一：在宿主aplication及插件activity重写getResource()  ，弊端再使用公共的库时

会出现资源冲突（比如AppCompatActivity）



方式二：解决方式一的问题，替换插件activity的context，可以解决方式一问题的原因是

AppCompatActivity使用了宿主的context进行，而setContentView使用了自己的context

```
mContext = new ContextThemeWrapper(this.getApplicationContext(), R.style.PluginTheme);
Field resourceField = mContext.getClass().getDeclaredField("mResources");
resourceField.setAccessible(true);
resourceField.set(mContext, getPluginResources(this.getApplicationContext()));
Log.i(TAG, "hook resource");
```

  



## jetpack



## JVM

JVM是一种规范

JVM 不单单支持Java，比如Kotlin...

Android的虚拟机：Google Android Dalivk VM

![虚拟机栈的执行过程演示](G:\好好学习daydayup\享学课堂资料\Java语言进阶\1、虚拟机的前世今生，深入理解JVM内存区域等4个文件\虚拟机栈的执行过程演示.png)



程序计数器：Java支持多线程，线程之间存在切换，确保多线程正常执行。

虚拟机栈：FILO数据结构，非常符合Java中的方法之间的调用

属于线程私有，每次执行一个方法，都打包成一个栈帧

每个时刻正在执行的方法就是栈顶的栈帧，方法的执行就对应着栈帧在虚拟机栈中入栈出栈的过程

![image-20200408095017778](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200408095017778.png)







方法区：主要存储被虚拟机加载的类的信息，静态变量，常量

堆：几乎所有的对象都在堆分配，也是垃圾回收的主要区域（GC:Garbage Collection）



直接内存:不是虚拟机运行时的数据区的一部分，也不是JVM虚拟机规范中定义的内存区域。

如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；

这块内存不受堆大小限制



![image-20200408102127527](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200408102127527.png)



堆与栈区别：

1.栈线程私有，堆线程共享

2.栈内存随线程消亡而消失，堆内存需要GC

3.栈 < 堆（远远小于）



栈溢出：StackOverFlowError，一般调用不会出现，比如无限递归

虚拟机栈给我们的启示：方法的执行要打包成栈帧，所有天生要比实现同样的功能的循环慢

比如：树的算法中，递归代码整洁，非递归复杂但是速度快



虚拟机中对象

分配过程：new

1.先执行相应的类加载过程

2.分配内存: CAS机制 （ABA ）

3.内存空间初始化：注意不是构造方法

4.设置：对象头(哪个类的实例，hashcode，GC ...)

5.对象初始化(构造方法？)



对象的内存布局：1.对象头 2.实例数据  3.对齐填充（8字节的整数倍）

![image-20200408135628037](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200408135628037.png)



对象的访问定位:直接指针，句柄（栈的引用指向句柄地址，而句柄包含对象实例数据与类型数据各自的具体地址信息）

区别:reference存储的句柄稳定的地址，在对象被移动是只需要修改句柄中的实例对象数据的地址，而reference不用修改；直接指针，速度快

Sun HotSpot 是使用直接指针

![image-20200408135535790](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200408135535790.png)

逃逸分析:

虚拟机的优化技术，基本思想是，对于线程私有对象，将它打散分配在栈上，而不分配在堆上

好处是对象跟方法调用而自行销毁，不需要垃圾回收，可以提供性能





## Binder

四大组件通讯：binder

插件化是多个进程？







## 并发编程

进程：程序进行资源分配的最小单位

线程：cpu调度最小单位

上下文切换？20000周期

CUP时间片轮转调度



并行：

![image-20200517100501615](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517100501615.png)

并行：

![image-20200517100510512](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517100510512.png)



线程启动：

线程启动的两种方式：Runnable 更像是任务抽象



线程停止：

Thread.stop(): 会导致内存不能回放

线程是协作性（interrput，isInterrput,Thread.interrputed），不是抢占式（stop）

静态Thread.interrputed() 调用之后，会清除中断标准位

Thread.currentThread().interrput,在Runnable里调用

![image-20200517105110563](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517105110563.png)

死锁状态下，是不会理会中断？



线程状态:

线程状态/生命周期：当且仅当synchronized时才会导致线程进入阻塞（BLOCKED）



![image-20200517112958159](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517112958159.png)





A.join:等到A线程执行完，才执行（如何让两个线程顺序执行）

守护线程：框架中内存管理线程

![image-20200517120056490](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517120056490.png)



synchronized锁：本质加锁对象

1.对象锁

2.类锁：static 修饰



显示锁？

上下文切换是指什么？



并发问题根源（https://zhuanlan.zhihu.com/p/64988344）：

可见性：缓存导致可见性问题

![preview](https://pic4.zhimg.com/v2-a263be2c59ea2ae1589fe87916e6a35b_r.jpg)



原子性：CPU线程切换导致原子性问题

![img](https://pic2.zhimg.com/80/v2-61a50aab2da597e9a97f19689ab3519d_720w.jpg)



有序性：编译器优化导致指令重排序问题（双重检查锁，不加volatile）

![image-20200517150124782](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517150124782.png)

  

  原子性：意思是操作不可拆分，要么全部执行，要么全部不执行

 可见性：为啥会需要可见性

 有序性：





CAS:如果这个地址的值和期望的值相同，就赋值新计算的值，否则不做任何事，返回原值，下一循环重复

![image-20200513101514865](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200513101514865.png)

CAS：缺点：引发ABA（女朋友原理），开销大（循环），适用单一共享变量



死锁概念：（指的是线程还是进程争夺资源？）

1.互斥条件

2.请求和保持条件

3.不可剥夺

4.环路等待



1.M（M>=2）个操作者,争夺N(N>=2)个资源，且N<=M

2.争夺资源的顺序不对

3.争夺者拿到资源不释放

解决死锁问题:破坏后面两个条件



ThteadLocal 还没有完全懂：（使用：线程本地变量,Looper）

```
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

```
/**
 * Get the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param  t the current thread
 * @return the map
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

```
/**
 * Create the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param t the current thread
 * @param firstValue value for the initial entry of the map
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

```
/**
 * Construct a new map initially containing (firstKey, firstValue).
 * ThreadLocalMaps are constructed lazily, so we only create
 * one when we have at least one entry to put in it.
 */
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY];
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    table[i] = new Entry(firstKey, firstValue);
    size = 1;
    setThreshold(INITIAL_CAPACITY);
}
```

```
/**
 * The entries in this hash map extend WeakReference, using
 * its main ref field as the key (which is always a
 * ThreadLocal object).  Note that null keys (i.e. entry.get()
 * == null) mean that the key is no longer referenced, so the
 * entry can be expunged from table.  Such entries are referred to
 * as "stale entries" in the code that follows.
 */
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```





## 阻塞队列及线程池



线程池执行策略：

![image-20200517154318861](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517154318861.png)

参数配置：

cup密集形：max=Runtime.getRuntime().availableProcessors()+1(+1,磁盘  虚拟内存)

io密集形：网络通讯、读写磁盘，max=机器cup核心数*2 （经验值）

混合形：cup密集跟io密集处理时间差不多，拆分两个线程池；如果io比较多，就当然io密集来处理



![img](file:///C:\Users\Abero\AppData\Roaming\Tencent\Users\1032041993\TIM\WinTemp\RichOle\2UZ_QX8QDH0[5`2Z5`D{MZJ.png)



## 深入理解并发编程及归纳总结



AQS（同步其）:用来构建锁和同步组件的基础框架

原理？：int statte+CLH+模板方法



可重入:比如递归的时候，指任意线程获取到锁之后，能够再次获取该锁而不会被锁所阻塞



JMM :java memory model,工作缓存-主存



？这一期要重新看



第二节：





new object();

1.对象头，GC年龄....  MarkWord   

2.对象 类   类型指针  KclassPoint 



轻量锁：CAS   自适应自旋锁： 次数控制，一个线程的上下文切换

偏向锁：1一个锁，大多数情况同一个线程 CAS不想做了



尽量使用synchronied ，对于显示Lock（除非有需求tryLock等）

类的静态方法？ simpleOper.class 对象？

![image-20200519212517742](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200519212517742.png)



锁哪几类？

synchronied 是非公平锁？可重入？阻塞？

AQS实现：

与Re区别？

synchronized static 与非static区别喝范围

DCL?





## NDK

JNI:是java调用其他本地语言的，不一定是c/c++

JNI编程指南.pdf   下载自己看看



为啥要用JNI

1.java是跨平台，与本地代码交互能力非常弱

2.性能，安全，易于复用和移植

NDK:Android的一个开发工具包



go->so->jni?



静态库：已链接？

动态库：对一些函数库，运行时链接



JNIEvn   java环境，创建jobject，修改属性，调用方法

jni函数签名，javap

javac PsStoreTest.java

javap -s -p PsStoreTest.class





## 泛型反射、注解

参数类型化

好处：

1.适用于多种类型参数执行相同的代码

2.、不需要强制类型转行，避免classcastExecption



![image-20200528112915259](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200528112915259.png)





![image-20200528113044668](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200528113044668.png)



![image-20200528113102151](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200528113102151.png)



子类：  ？extends T

超类：  ?  super T

Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。



反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法

反射是java是动态语言的关键，可以构造任意对象，访问任意属性及方法

类的元数据信息？

class的用来描述类的类



注解：

注解原理：

三种使用场景：

1.source   IDE语法检测（参数限定），APT

2.class      操作字节码

3.runntime   反射















## Gson



kotlin moshi



几个注解：

1.版本

2.选择性序列化

3.。。。



自定义：typeAdapter？ 处理好坑的后天返回 jsonarray jsonobject null？



json解析流程：

Type？  TypeToken?  反射

反射课需要重新看!



























































































