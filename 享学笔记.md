# 享学笔记 

## 插件化

类加载流程图：双亲委派机制

DexClassLoader ==PathDexClassLoader

应用							

BootClassLoader

系统

![](C:\Users\Abero\Desktop\classloader.png)

插件化类加载实现流程图

![](C:\Users\Abero\Desktop\plugin_classloader.png)



资源加载

```
AssetManager assetManager = AssetManager.class.newInstance();
Method addAssetPathMethod = assetManager.getClass().getMethod("addAssetPath", String.class);
addAssetPathMethod.setAccessible(true);
addAssetPathMethod.invoke(assetManager, apkPath);
Resources hostResource = context.getResources();
resources = new Resources(assetManager, context.getResources().getDisplayMetrics(),
        context.getResources().getConfiguration());
```

方式一：在宿主aplication及插件activity重写getResource()  ，弊端再使用公共的库时

会出现资源冲突（比如AppCompatActivity）



方式二：解决方式一的问题，替换插件activity的context，可以解决方式一问题的原因是

AppCompatActivity使用了宿主的context进行，而setContentView使用了自己的context

```
mContext = new ContextThemeWrapper(this.getApplicationContext(), R.style.PluginTheme);
Field resourceField = mContext.getClass().getDeclaredField("mResources");
resourceField.setAccessible(true);
resourceField.set(mContext, getPluginResources(this.getApplicationContext()));
Log.i(TAG, "hook resource");
```

  



## jetpack



## JVM

JVM是一种规范

JVM 不单单支持Java，比如Kotlin...

Android的虚拟机：Google Android Dalivk VM

![虚拟机栈的执行过程演示](G:\好好学习daydayup\享学课堂资料\Java语言进阶\1、虚拟机的前世今生，深入理解JVM内存区域等4个文件\虚拟机栈的执行过程演示.png)



程序计数器：Java支持多线程，线程之间存在切换，确保多线程正常执行。

虚拟机栈：FILO数据结构，非常符合Java中的方法之间的调用

属于线程私有，每次执行一个方法，都打包成一个栈帧

每个时刻正在执行的方法就是栈顶的栈帧，方法的执行就对应着栈帧在虚拟机栈中入栈出栈的过程

![image-20200408095017778](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200408095017778.png)







方法区：主要存储被虚拟机加载的类的信息，静态变量，常量

堆：几乎所有的对象都在堆分配，也是垃圾回收的主要区域（GC:Garbage Collection）



直接内存:不是虚拟机运行时的数据区的一部分，也不是JVM虚拟机规范中定义的内存区域。

如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；

这块内存不受堆大小限制



![image-20200408102127527](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200408102127527.png)



堆与栈区别：

1.栈线程私有，堆线程共享

2.栈内存随线程消亡而消失，堆内存需要GC

3.栈 < 堆（远远小于）



栈溢出：StackOverFlowError，一般调用不会出现，比如无限递归

虚拟机栈给我们的启示：方法的执行要打包成栈帧，所有天生要比实现同样的功能的循环慢

比如：树的算法中，递归代码整洁，非递归复杂但是速度快



虚拟机中对象

分配过程：new

1.先执行相应的类加载过程

2.分配内存: CAS机制 （ABA ）

3.内存空间初始化：注意不是构造方法

4.设置：对象头(哪个类的实例，hashcode，GC ...)

5.对象初始化(构造方法？)



对象的内存布局：1.对象头 2.实例数据  3.对齐填充（8字节的整数倍）

![image-20200408135628037](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200408135628037.png)



对象的访问定位:直接指针，句柄（栈的引用指向句柄地址，而句柄包含对象实例数据与类型数据各自的具体地址信息）

区别:reference存储的句柄稳定的地址，在对象被移动是只需要修改句柄中的实例对象数据的地址，而reference不用修改；直接指针，速度快

Sun HotSpot 是使用直接指针

![image-20200408135535790](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200408135535790.png)

逃逸分析:

虚拟机的优化技术，基本思想是，对于线程私有对象，将它打散分配在栈上，而不分配在堆上

好处是对象跟方法调用而自行销毁，不需要垃圾回收，可以提供性能





## Binder

四大组件通讯：binder

插件化是多个进程？





## 并发编程

进程：程序进行资源分配的最小单位

线程：cpu调度最小单位

上下文切换？20000周期

CUP时间片轮转调度



并行：

![image-20200517100501615](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517100501615.png)

并行：

![image-20200517100510512](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517100510512.png)



线程启动：

线程启动的两种方式：Runnable 更像是任务抽象



线程停止：

Thread.stop(): 会导致内存不能回放

线程是协作性（interrput，isInterrput,Thread.interrputed），不是抢占式（stop）

静态Thread.interrputed() 调用之后，会清除中断标准位

Thread.currentThread().interrput,在Runnable里调用

![image-20200517105110563](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517105110563.png)

死锁状态下，是不会理会中断？



线程状态:

线程状态/生命周期：当且仅当synchronized时才会导致线程进入阻塞（BLOCKED）



![image-20200517112958159](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517112958159.png)





A.join:等到A线程执行完，才执行（如何让两个线程顺序执行）

守护线程：框架中内存管理线程

![image-20200517120056490](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517120056490.png)



synchronized锁：本质加锁对象

1.对象锁

2.类锁：static 修饰



显示锁？

上下文切换是指什么？



并发问题根源（https://zhuanlan.zhihu.com/p/64988344）：

可见性：缓存导致可见性问题

![preview](https://pic4.zhimg.com/v2-a263be2c59ea2ae1589fe87916e6a35b_r.jpg)



原子性：CPU线程切换导致原子性问题

![img](https://pic2.zhimg.com/80/v2-61a50aab2da597e9a97f19689ab3519d_720w.jpg)



有序性：编译器优化导致指令重排序问题（双重检查锁，不加volatile）

![image-20200517150124782](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200517150124782.png)

  

  原子性：意思是操作不可拆分，要么全部执行，要么全部不执行

 可见性：为啥会需要可见性

 有序性：





CAS:如果这个地址的值和期望的值相同，就赋值新计算的值，否则不做任何事，返回原值，下一循环重复

![image-20200513101514865](C:\Users\Abero\AppData\Roaming\Typora\typora-user-images\image-20200513101514865.png)

CAS：缺点：引发ABA（女朋友原理），开销大（循环），适用单一共享变量



死锁概念：

1.互斥条件

2.请求和保持条件

3.不可剥夺

4.环路等待



1.M（M>=2）个操作者,争夺N(N>=2)个资源，且N<=M

2.争夺资源的顺序不对

3.争夺者拿到资源不释放

解决死锁问题:破坏后面两个条件



ThteadLocal 还没有完全懂：（使用：线程本地变量,Looper）

```
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

```
/**
 * Get the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param  t the current thread
 * @return the map
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

```
/**
 * Create the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param t the current thread
 * @param firstValue value for the initial entry of the map
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

```
/**
 * Construct a new map initially containing (firstKey, firstValue).
 * ThreadLocalMaps are constructed lazily, so we only create
 * one when we have at least one entry to put in it.
 */
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY];
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    table[i] = new Entry(firstKey, firstValue);
    size = 1;
    setThreshold(INITIAL_CAPACITY);
}
```

```
/**
 * The entries in this hash map extend WeakReference, using
 * its main ref field as the key (which is always a
 * ThreadLocal object).  Note that null keys (i.e. entry.get()
 * == null) mean that the key is no longer referenced, so the
 * entry can be expunged from table.  Such entries are referred to
 * as "stale entries" in the code that follows.
 */
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```





## 阻塞队列及线程池













































































